#lang ragg

/*
  name: BalancedGrammar 
*/

program: prelude block

prelude: [provide-stmt] [provide-types-stmt] import-stmt*

import-stmt: PARENNOSPACE (COMMA)* RPAREN
provide-stmt: stmt
provide-types-stmt: record-ann

block: stmt*

stmt: type-expr | spy-stmt
    | let-expr | fun-expr | data-expr | when-expr
    | var-expr | rec-expr | assign-expr | check-test | check-expr
    | contract-stmt

spy-stmt: SPY [binop-expr] COLON [spy-contents] END
spy-contents: spy-field (COMMA spy-field)*
spy-field: COLON binop-expr

type-expr: TYPE ty-params EQUALS ann
let-expr: toplevel-binding EQUALS binop-expr
binding: name-binding | tuple-binding

tuple-binding: LBRACE (binding SEMI)* binding [SEMI] RBRACE [name-binding]
name-binding: [COLONCOLON ann]

toplevel-binding: binding
multi-let-expr: LET let-binding (COMMA let-binding)* (BLOCK|COLON) block END
let-binding: let-expr | var-expr
letrec-expr: LETREC let-expr (COMMA let-expr)* (BLOCK|COLON) block END

type-bind: ty-params EQUALS ann

type-let-bind: [type-bind] 
type-let-expr: TYPE-LET type-let-bind (COMMA type-let-bind)* (BLOCK|COLON) block END

contract-stmt: COLONCOLON (ann | noparen-arrow-ann)

fun-expr: FUN fun-header (BLOCK|COLON) block where-clause END
fun-header: ty-params args return-ann
ty-params: [(LANGLE|LT) (COMMA)* (RANGLE|GT)]
args: (PARENNOSPACE|PARENAFTERBRACE) [binding (COMMA binding)*] RPAREN
return-ann: [THINARROW ann]
where-clause: [WHERE block]

check-expr: (CHECK|EXAMPLES) COLON block END
check-expr: (CHECKCOLON|EXAMPLESCOLON) block END
check-test: binop-expr [(PARENSPACE|PARENNOSPACE) binop-expr RPAREN] binop-expr
          | binop-expr


data-expr: DATA ty-params COLON [first-data-variant] data-variant* data-sharing where-clause END
variant-constructor: variant-members
first-data-variant: variant-constructor data-with | data-with
data-variant: BAR variant-constructor data-with | BAR data-with
variant-members: PARENNOSPACE [variant-member (COMMA variant-member)*] RPAREN
variant-member: [REF] binding
data-with: [WITH fields]
data-sharing: [SHARING fields]

var-expr: VAR toplevel-binding EQUALS binop-expr
rec-expr: REC toplevel-binding EQUALS binop-expr
assign-expr: COLONEQUALS binop-expr

when-expr: WHEN binop-expr (BLOCK|COLON) block END

binop-expr: expr (binop expr)*

binop: PLUS | DASH | STAR | SLASH | LEQ | GEQ | EQUALEQUAL | SPACESHIP | EQUALTILDE
     | NEQ  | LT  | GT | AND | OR | CARET

expr: paren-expr
    | lambda-expr | method-expr | app-expr
    | obj-expr | tuple-expr | tuple-get
    | dot-expr
    | template-expr
    | bracket-expr  # NOTE(joe): experimental for access
    | get-bang-expr | update-expr
    | extend-expr
    | if-expr | if-pipe-expr | cases-expr
    | for-expr
    | user-block-expr | inst-expr
    | multi-let-expr | letrec-expr
    | type-let-expr
    | construct-expr
    | table-select
    | table-extend
    | table-filter
    | table-order
    | table-extract
    | table-update
    | table-expr
    | load-table-expr
    | reactor-expr

template-expr : DOTDOTDOT

bad-expr: UNTERMINATED-STRING | UNTERMINATED-BLOCK-COMMENT | BAD-OPER | BAD-NUMBER | UNKNOWN

# paren-exprs must be preceded by a space, so as not be be confused with
# function application
paren-expr: (PARENSPACE|PARENAFTERBRACE) binop-expr RPAREN

lambda-expr: LAM fun-header (BLOCK|COLON) block where-clause END
lambda-expr: LBRACE fun-header (BLOCK|COLON) block where-clause RBRACE

method-expr: METHOD fun-header (BLOCK|COLON) block where-clause END

app-expr: expr app-args
# application must have the function expression immediately adjacent to
# the argument list, so as not to be confused with parenthesized exprs
app-args: PARENNOSPACE opt-comma-binops RPAREN
opt-comma-binops: [comma-binops]
comma-binops: binop-expr (COMMA binop-expr)*
trailing-opt-comma-binops: (comma-binops [COMMA] | )
# app-arg-elt: binop-expr COMMA

# at least one annotation must be provided
inst-expr: expr LANGLE ann (COMMA ann)* RANGLE

tuple-expr: LBRACE tuple-fields RBRACE
tuple-fields: binop-expr (SEMI binop-expr)* [SEMI]

tuple-get: expr DOT LBRACE RBRACE


obj-expr: LBRACE obj-fields RBRACE | LBRACE RBRACE
obj-fields: obj-field (COMMA obj-field)* [COMMA]
obj-field: COLON binop-expr
     | REF [COLONCOLON ann] COLON binop-expr
     | METHOD fun-header (BLOCK|COLON) block where-clause END

fields: field (COMMA field)* [COMMA]
field: COLON binop-expr
     | METHOD fun-header (BLOCK|COLON) block where-clause END

construct-expr: LBRACK construct-modifier binop-expr COLON trailing-opt-comma-binops RBRACK
construct-modifier: | LAZY

table-expr: TABLE table-headers table-rows END
table-headers: [list-table-header* table-header]
list-table-header: table-header COMMA
table-header: [COLONCOLON ann]
table-rows: [table-row* table-row]
table-row: ROW table-items
table-items: [list-table-item* binop-expr]
list-table-item: binop-expr COMMA

# NOTE(joe): just parsing as "fields" for now, and handling naming in
# desugaring/well-formed, so that better error messages can be given
reactor-expr: REACTOR COLON
  fields
END

dot-expr: expr DOT
bracket-expr: expr LBRACK binop-expr RBRACK

get-bang-expr: expr BANG

extend-expr: expr DOT LBRACE fields RBRACE
update-expr: expr BANG LBRACE fields RBRACE

if-expr: IF binop-expr (BLOCK|COLON) block else-if* [ELSECOLON block] END
else-if: ELSEIF binop-expr COLON block
if-pipe-expr: ASK (BLOCK|COLON) if-pipe-branch* [BAR OTHERWISECOLON block] END
if-pipe-branch: BAR binop-expr THENCOLON block

cases-binding: [REF] binding
cases-args: PARENNOSPACE [cases-binding (COMMA cases-binding)*] RPAREN
cases-expr: CASES (PARENSPACE|PARENNOSPACE) ann RPAREN binop-expr (BLOCK|COLON) cases-branch* [BAR ELSE THICKARROW block] END
cases-branch: BAR [cases-args] THICKARROW block

for-bind: binding FROM binop-expr
for-expr: FOR expr PARENNOSPACE [for-bind (COMMA for-bind)*] RPAREN return-ann (BLOCK|COLON) block END

column-order : (ASCENDING|DESCENDING)
table-select : TABLE-SELECT (COMMA)* FROM expr END
table-filter : TABLE-FILTER expr [binding (COMMA binding)*] COLON binop-expr END
table-order  : TABLE-ORDER  expr COLON column-order (COMMA column-order)* END
table-extract: TABLE-EXTRACT NAME FROM expr END
table-update : TABLE-UPDATE expr [binding (COMMA binding)*] COLON obj-fields END
table-extend : TABLE-EXTEND expr [binding (COMMA binding)*] COLON table-extend-fields END
table-extend-fields: list-table-extend-field* table-extend-field [COMMA]
list-table-extend-field: table-extend-field COMMA
table-extend-field: [COLONCOLON ann] COLON binop-expr
     | [COLONCOLON ann] COLON expr

# More informative to allow missing load-table-specs to parse and mark it as a
# well-formedness error than to reject it at parse-time
load-table-expr: LOAD-TABLE COLON table-headers [load-table-specs] END

load-table-specs: load-table-spec* load-table-spec
load-table-spec: SOURCECOLON expr
               | SANITIZE NAME USING expr

user-block-expr: BLOCK block END

ann: record-ann | arrow-ann | app-ann | pred-ann | dot-ann | tuple-ann

comma-ann-field: ann-field (COMMA ann-field)*
trailing-opt-comma-ann-field: (comma-ann-field [COMMA] | )
record-ann: LBRACE trailing-opt-comma-ann-field RBRACE
ann-field: COLONCOLON ann

tuple-ann: LBRACE ann (SEMI ann)* [SEMI] RBRACE

noparen-arrow-ann: [arrow-ann-args] THINARROW ann
arrow-ann-args: comma-anns | (PARENSPACE|PARENNOSPACE|PARENAFTERBRACE) comma-ann-field RPAREN
arrow-ann: (PARENSPACE|PARENNOSPACE|PARENAFTERBRACE) [arrow-ann-args] THINARROW ann RPAREN

app-ann: (dot-ann) LANGLE comma-anns RANGLE

comma-anns: ann (COMMA ann)*

pred-ann: ann (PARENSPACE|PARENNOSPACE) RPAREN

dot-ann : DOT
